public class FieldLayout implements LayoutManager, LayoutManager2, IFSLayout, Serializable {

    private static final long serialVersionUID = 8031350278456473202L;

    private int width = -1;
    private ArrayList<FieldRowWrapper> rows = null;
    private ArrayList<FieldColumnWrapper> columns = null;

    public FieldLayout() {
    }

    @Override
    public void addLayoutComponent(Component comp, Object constraints) {
        // Not used by this class
    }

    @Override
    public float getLayoutAlignmentX(Container target) {
        return 0;
    }

    @Override
    public float getLayoutAlignmentY(Container target) {
        return 0;
    }

    @Override
    public void invalidateLayout(Container target) {
        // Not used by this class
    }

    @Override
    public void invalidateMinimumHeight(Container container) {
        this.width = -1;
    }

    @Override
    public void addLayoutComponent(String name, Component comp) {
        // Not used by this class
    }

    @Override
    public void removeLayoutComponent(Component comp) {
        // Not used by this class
    }

    @Override
    public Dimension maximumLayoutSize(Container container) {
        synchronized (container.getTreeLock()) {
            return this.measureMaximumSize((DevControlFieldPanel) container);
        }
    }

    @Override
    public Dimension preferredLayoutSize(Container container) {
        synchronized (container.getTreeLock()) {
            return this.measureMinimumSize((DevControlFieldPanel) container);
        }
    }

    @Override
    public Dimension minimumLayoutSize(Container container) {
        synchronized (container.getTreeLock()) {
            return this.measureMinimumSize((DevControlFieldPanel) container);
        }
    }

    @Override
    public int minimumLayoutHeight(Container container, int width) {
        synchronized (container.getTreeLock()) {
            return this.measureMinimumHeight((DevControlFieldPanel) container, width);
        }
    }

    @Override
    public void layoutContainer(Container container) {
        synchronized (container.getTreeLock()) {
            this.arrange((DevControlFieldPanel) container);
        }
    }

    private Dimension measureMaximumSize(DevControlFieldPanel devControlFieldPanel) {
        UIFieldPanel uiFieldPanel = (UIFieldPanel)devControlFieldPanel.getUIItem();
        return new Dimension(
                JavaUtil.maxValue(UIItem.addMargin(uiFieldPanel.getMaxWidth(), uiFieldPanel.getMarginLeft(), uiFieldPanel.getMarginRight())),
                JavaUtil.maxValue(UIItem.addMargin(uiFieldPanel.getMaxHeight(), uiFieldPanel.getMarginTop(), uiFieldPanel.getMarginBottom())));
    }

    private void initRows(DevControlFieldPanel devControlFieldPanel) {
        this.rows = new ArrayList<FieldRowWrapper>();

        // remember all IControlLabel children
        // those control labels, which will not be added again, have to be removed
        ArrayList<Component> controlLabels = new ArrayList<Component>();
        for(Component child : devControlFieldPanel.getComponents()) {
            if (child instanceof IControlLabel) {
                controlLabels.add(child);
            }
        }

        // iterate children and fill wrapper array
        VchContainer vchContainer = ((UIContainer) devControlFieldPanel.getUIItem()).getVchContainer();
        for (UIItem uiItem : vchContainer.getChildren()) {

            UIFieldRow uiFieldRow = (UIFieldRow)uiItem;

            // check, if at least one control of this row is visible
            boolean isRowVisible = false;
            for (UIItem rowItem : uiFieldRow.getVchContainer().getChildren()) {

                if (rowItem.getControlVisibility() != FSVisibility.COLLAPSED) {
                    isRowVisible = true;
                    break;
                }
            }

            if (isRowVisible && uiFieldRow.getControlVisibility() != FSVisibility.COLLAPSED) {
                this.rows.add(new FieldRowWrapper(uiFieldRow, controlLabels));
            }
        }

        for (Component controlLabelToDelete : controlLabels) {
            devControlFieldPanel.remove(controlLabelToDelete);
        }
    }

    private Dimension measureMinimumSize(DevControlFieldPanel devControlFieldPanel) {

        UIFieldPanel uiFieldPanel = (UIFieldPanel)devControlFieldPanel.getUIItem();

        // init rows
        this.initRows(devControlFieldPanel);

        // init columns in grid mode
        boolean isGridMode = uiFieldPanel.getSynchronizeColumns();
        if (isGridMode) {
            this.columns = new ArrayList<FieldColumnWrapper>();

            int maxCellCount = 0;
            for (FieldRowWrapper row : this.rows) {
                maxCellCount = Math.max(maxCellCount, row.getCellsCount());
            }

            // build columns for all cells
            for (int i = 0; i < maxCellCount; i++) {
                ArrayList<CellWrapper> columnCells = new ArrayList<CellWrapper>();
                for(FieldRowWrapper row : this.rows) {
                    if (row.labelMode != FieldRowLabelMode.NONE_FILL && i < row.getCellsCount()) {
                        columnCells.add(row.getCell(i));
                    }
                }
                this.columns.add(new FieldColumnWrapper(columnCells));
            }
        }

        // sum up cell min widths (care about columns), add spacings for each row
        // and get the widest rows min width.
        int hSpacing = uiFieldPanel.getSpacingHorizontal();
        int minWidth = 0;
        for (FieldRowWrapper row : this.rows) {
            int rowMinWidth = 0;
            boolean isFirst = true;
            for (CellWrapper cell : row.cells) {
                if (!cell.isVisible() && !isGridMode) {
                    // ignore invisible cells in normal mode
                    continue;
                }

                if (isFirst) {
                    rowMinWidth += cell.getColumnOrCellMinWidth();
                    isFirst = false;
                } else {
                    rowMinWidth += hSpacing + cell.getColumnOrCellMinWidth();
                }

            }
            minWidth = Math.max(minWidth, rowMinWidth);
        }

        if (minWidth > 0) {
            // include insets (padding) of the container
            Insets insets = devControlFieldPanel.getInsets();
            minWidth += insets.left + insets.right;
        }

        // determine at the container defined minimum size (including margin)
        Integer containerMinWidth = UIItem.addMargin(uiFieldPanel.getMinWidth(), uiFieldPanel.getMarginLeft(), uiFieldPanel.getMarginRight());

        // the greater value wins: calculated minimum size for all children or defined container minimum size
        minWidth = Math.max(minWidth, JavaUtil.minValue(containerMinWidth));

        // min height is irrelevant for IFSLayout.measureMinimumSize(...)
        return new Dimension(minWidth, 0);
    }

    private int measureMinimumHeight(DevControlFieldPanel devControlFieldPanel, int width) {

        this.width = width;

        UIFieldPanel uiFieldPanel = (UIFieldPanel)devControlFieldPanel.getUIItem();

        // insets (padding) of the container
        Insets insets = devControlFieldPanel.getInsets();

        int hSpacing = uiFieldPanel.getSpacingHorizontal();
        int vSpacing = uiFieldPanel.getSpacingVertical();

        // do horizontal layout => all controls know their result width
        boolean isGridMode = uiFieldPanel.getSynchronizeColumns();
        boolean isFirstRow = true;
        int minHeight = 0;

        // in grid mode only: set result column width
        if (isGridMode) {

            // stretch columns horizontally
            int availableWidth = width - insets.left - insets.right;

            // set column result width = min width for the first column and not stretchable columns
            // and update the available width (care about horizontal spacings)
            // remember columns todo
            LinkedList<FieldColumnWrapper> todo = new LinkedList<FieldColumnWrapper>();
            boolean isFirstColumn = true;
            for (FieldColumnWrapper column : this.columns) {
                if (isFirstColumn) {
                    column.setResultColumnWidth(column.getMinColumnWidth());
                    availableWidth -= column.getResultColumnWidth();
                    isFirstColumn = false;
                } else {
                    if (column.isHorizontalStretchable()) {
                        todo.add(column);
                    } else {
                        column.setResultColumnWidth(column.getMinColumnWidth());
                        availableWidth -= hSpacing;
                        availableWidth -= column.getResultColumnWidth();
                    }
                }
            }

            // stretch columns to fill the available width

            // reduce the available width by needed spacings
            availableWidth -= Math.max(0, todo.size() - 1) * hSpacing;

            int sumMinWidths = 0;
            for (FieldColumnWrapper column : todo) {
                sumMinWidths += column.getMinColumnWidth();
            }

            // calculate desired width an care about max width
            float stretchFactor = (float) availableWidth / (float) sumMinWidths;
            boolean allProblemsSolved = false;
            while (!allProblemsSolved && !todo.isEmpty()) {
                allProblemsSolved = true;

                LinkedList<FieldColumnWrapper> currentTodo = new LinkedList<FieldColumnWrapper>(todo);
                for (FieldColumnWrapper column : currentTodo) {
                    float desiredWidth = stretchFactor * (float)column.getMinColumnWidth();
                    if (column.getMaxColumnWidth() < desiredWidth) {
                        // desired size conficts max size => aling using max size
                        column.setResultColumnWidth(column.getMaxColumnWidth());
                        sumMinWidths -= column.getMinColumnWidth();
                        availableWidth -= column.getMaxColumnWidth();
                        stretchFactor = (float) availableWidth / (float) sumMinWidths;
                        allProblemsSolved = false;
                        todo.remove(column);
                    }
                }
            }

            // if there are still column not stretched, stretch them
            // they will not have any problems
            while (!todo.isEmpty()) {
                FieldColumnWrapper column = todo.poll();
                column.setResultColumnWidth(Math.round(stretchFactor * (float)column.getMinColumnWidth()));

                // recalculate stretch factor to aviod rounding errors
                sumMinWidths -= column.getMinColumnWidth();
                availableWidth -= column.getResultColumnWidth();
                stretchFactor = (float) availableWidth / (float) sumMinWidths;
            }
        }

        for(FieldRowWrapper row : this.rows) {
            if (isGridMode) {
                // grid mode

                for (CellWrapper cell : row.getCells()) {
                    if (cell.getAlignmentHorizontal() == HorizontalAlignment.STRETCH) {
                        cell.setResultWidth(Math.min(cell.getColumn().getResultColumnWidth(), cell.getMaxWidth()));
                    } else {
                        cell.setResultWidth(cell.getMinWidth());
                    }
                }

            } else {
                // normal mode

                int availableWidth = width - insets.left - insets.right;

                // set result width = min width for first cell and not stretchable cells
                // and update the available width (care about horizontal spacings)
                // remember cells todo
                LinkedList<CellWrapper> todo = new LinkedList<CellWrapper>();
                boolean isFirstCell = true;
                for (CellWrapper cell : row.getCells()) {
                    if (isFirstCell && row.labelMode != FieldRowLabelMode.NONE_FILL) {
                        cell.setResultWidth(cell.getMinWidth());
                        availableWidth -= cell.getResultWidth();
                        isFirstCell = false;
                    } else {
                        if (cell.isVisible()) {
                            if (cell.getAlignmentHorizontal() == HorizontalAlignment.STRETCH) {
                                todo.add(cell);
                            } else {
                                cell.setResultWidth(cell.getMinWidth());
                                availableWidth -= hSpacing;
                                availableWidth -= cell.getResultWidth();
                            }
                        }

                    }
                }

                // stretch items to fill the available width

                // reduce the available width by needed spacings
                availableWidth -= Math.max(0, todo.size() - 1) * hSpacing;

                int sumMinWidths = 0;
                for (CellWrapper cell : todo) {
                    sumMinWidths += cell.getMinWidth();
                }

                // calculate desired width an care about alignment and max width
                float stretchFactor = (float) availableWidth / (float) sumMinWidths;
                boolean allProblemsSolved = false;
                while (!allProblemsSolved && !todo.isEmpty()) {
                    allProblemsSolved = true;

                    LinkedList<CellWrapper> currentTodo = new LinkedList<CellWrapper>(todo);
                    for (CellWrapper cell : currentTodo) {
                        if (cell.getAlignmentHorizontal() != HorizontalAlignment.STRETCH) {
                            // alignment != stretch => align using min width
                            cell.setResultWidth(cell.getMinWidth());
                            sumMinWidths -= cell.getMinWidth();
                            availableWidth -= cell.getMinWidth();
                            stretchFactor = (float) availableWidth / (float) sumMinWidths;
                            allProblemsSolved = false;
                            todo.remove(cell);
                        } else {
                            float desiredWidth = stretchFactor * (float)cell.getMinWidth();
                            if (cell.getMaxWidth() < desiredWidth) {
                                // desired size conficts max size => aling using max size
                                cell.setResultWidth(cell.getMaxWidth());
                                sumMinWidths -= cell.getMinWidth();
                                availableWidth -= cell.getMaxWidth();
                                stretchFactor = (float) availableWidth / (float) sumMinWidths;
                                allProblemsSolved = false;
                                todo.remove(cell);
                            }
                        }
                    }
                }

                // if there are still cells not stretched, stretch them
                // they will not have any problems
                while (!todo.isEmpty()) {
                    CellWrapper cell = todo.poll();
                    cell.setResultWidth(Math.round(stretchFactor * (float)cell.getMinWidth()));

                    // recalculate stretch factor to aviod rounding errors
                    sumMinWidths -= cell.getMinWidth();
                    availableWidth -= cell.getResultWidth();
                    stretchFactor = (float) availableWidth / (float) sumMinWidths;
                }

            }

            // for both modes:
            // now all result widths are set, so calculate min height for all rows
            // add them including vertical spaces.
            int rowMinHeight = 0;
            for (CellWrapper cell : row.getCells()) {
                rowMinHeight = Math.max(rowMinHeight, cell.getMinHeight());
            }
            row.setMinRowHeight(rowMinHeight);

            if (rowMinHeight > 0) {
                if (isFirstRow) {
                    isFirstRow = false;
                } else {
                    minHeight += vSpacing;
                }
                minHeight += rowMinHeight;
            }

        }

        return minHeight;
    }

    private void arrange(DevControlFieldPanel devControlFieldPanel) {
        UIFieldPanel uiFieldPanel = (UIFieldPanel)devControlFieldPanel.getUIItem();

        // consistency check
        if (devControlFieldPanel.getSize().width != this.width) {
            this.measureMinimumHeight(devControlFieldPanel, devControlFieldPanel.getSize().width);
        }

        // insets (padding) of the container
        Insets insets = devControlFieldPanel.getInsets();

        int vSpacing = uiFieldPanel.getSpacingVertical();

        int availableHeight = devControlFieldPanel.getSize().height - insets.top - insets.bottom;

        // reduce the available height by needed spacings
        availableHeight -= Math.max(0, this.rows.size() - 1) * vSpacing;

        // get sum of (visible) field row sizes
        int sumFieldRowSizes = 0;
        for (FieldRowWrapper row : this.rows) {
            if (row.getSize() != null && row.isStretchable()) {
                sumFieldRowSizes += row.getSize().intValue();
            }
        }

        // calculate result height for auto sized rows
        // and remember all dynamic rows to be processed later
        ArrayList<FieldRowWrapper> todo = new ArrayList<FieldRowWrapper>();
        for (FieldRowWrapper row : this.rows) {
            if (row.getSize() == null || !row.isStretchable()) {
                // auto sized rows: resultSize = minSize
                int minHeight = row.getMinRowHeight();
                row.setResultRowHeight(minHeight);
                availableHeight -= minHeight;
            } else {
                // dynamic rows: todo later
                todo.add(row);
            }
        }

        // calculate result height for dynamic rows respecting min and max height
        boolean allMinProblemsSolved = false;
        while (!todo.isEmpty() && !allMinProblemsSolved) {
            // sum up all distances below minimum
            // and remember the greatest distance item
            boolean hasMinFail = false;
            float maxMinFail = 0f;
            FieldRowWrapper maxMinFailWrapper = null;
            for (FieldRowWrapper row : todo) {
                float rowSizeRatio = (float)row.getSize() / (float)sumFieldRowSizes;
                float desiredHeight = rowSizeRatio * (float)availableHeight;
                float minFail = Math.max(0f, (float)row.getMinRowHeight() - desiredHeight);
                if (minFail > 0f) {
                    hasMinFail = true;
                    if (minFail > maxMinFail) {
                        maxMinFail = minFail;
                        maxMinFailWrapper = row;
                    }
                }
            }

            if (!hasMinFail) {
                // no problems concerning min and max size
                allMinProblemsSolved = true;
            } else {
                // min problem
                todo.remove(maxMinFailWrapper);
                maxMinFailWrapper.setResultRowHeight(maxMinFailWrapper.getMinRowHeight());
                availableHeight -= maxMinFailWrapper.getResultRowHeight();
                sumFieldRowSizes -= maxMinFailWrapper.getSize();
            }
        }

        // calculate result height for dynamic rows without problems concerning min height
        while (!todo.isEmpty()) {
            FieldRowWrapper row = todo.remove(0);
            float rowSizeRatio = (float)row.getSize() / (float)sumFieldRowSizes;
            int desiredHeight = Math.round(rowSizeRatio * (float)availableHeight);
            row.setResultRowHeight(desiredHeight);
            availableHeight -= row.getResultRowHeight();
            sumFieldRowSizes -= row.getSize();
        }

        // layout rows
        boolean addSpacing = false;
        int yPos = insets.top;
        for (FieldRowWrapper row : this.rows) {
            if (addSpacing) yPos += vSpacing;
            else addSpacing = true;

            this.arrangeRow(devControlFieldPanel, row, new Point(insets.left, yPos));

            yPos += row.getResultRowHeight();
        }

    }

    private void arrangeRow(DevControlFieldPanel devControlFieldPanel, FieldRowWrapper row, Point location) {

        UIFieldPanel uiFieldPanel = (UIFieldPanel)devControlFieldPanel.getUIItem();
        boolean isGridMode = uiFieldPanel.getSynchronizeColumns();
        int hSpacing = uiFieldPanel.getSpacingHorizontal();

        boolean addSpacing = false;
        int xPos = location.x;
        for (CellWrapper cell : row.getCells()) {
            VerticalAlignment alignmentVertical = cell.getAlignmentVertical();
            int cellHeight = alignmentVertical == VerticalAlignment.STRETCH ? row.getResultRowHeight() : cell.getMinHeight();
            cellHeight = Math.min(cellHeight, cell.getMaxHeight());

            if (addSpacing) xPos += hSpacing;
            else addSpacing = true;

            // calculate vertical offset (caused by vertical cell alignment)
            int yOffset = 0;
            if (alignmentVertical == VerticalAlignment.BOTTOM) {
                yOffset = row.getResultRowHeight() - cellHeight;
            } else if (alignmentVertical == VerticalAlignment.MIDDLE) {
                yOffset = (row.getResultRowHeight() - cellHeight) / 2;
            }

            if (isGridMode) {

                HorizontalAlignment alignmentHorizontal = cell.getAlignmentHorizontal();
                int xOffset = 0;
                if (alignmentHorizontal == HorizontalAlignment.RIGHT) {
                    xOffset = cell.getColumn().getResultColumnWidth() - cell.getResultWidth();
                } else if (alignmentHorizontal == HorizontalAlignment.CENTER) {
                    xOffset = (cell.getColumn().getResultColumnWidth() - cell.getResultWidth()) / 2;
                }

                cell.arrange(
                        new Point(xPos + xOffset, location.y + yOffset),
                        new Dimension(cell.getResultWidth(), cellHeight)
                        );
                xPos += cell.getColumn().getResultColumnWidth();

            } else {

                cell.arrange(
                        new Point(xPos, location.y + yOffset),
                        new Dimension(cell.getResultWidth(), cellHeight)
                        );

                xPos += cell.getResultWidth();

            }
        }
    }

}
